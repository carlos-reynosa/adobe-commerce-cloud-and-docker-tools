#!/usr/bin/env bash
# This file:
#
#  - Demos BASH3 Boilerplate (change this for your script)
#
# Usage:
#
#  LOG_LEVEL=7 ./main.sh -f /tmp/x -d (change this for your script)
#
# Based on a template by BASH3 Boilerplate v2.4.1
# http://bash3boilerplate.sh/#authors
#
# The MIT License (MIT)
# Copyright (c) 2013 Kevin van Zonneveld and contributors
# You are not obligated to bundle the LICENSE file with your b3bp projects as long
# as you leave these references intact in the header comments of your source files.

function initi-local-environment () {


# Exit on error. Append "|| true" if you expect an error.
set -o errexit
# Exit on error inside any functions or subshells.
set -o errtrace
# Do not allow use of undefined vars. Use ${VAR:-} to use an undefined VAR
set -o nounset
# Catch the error in case mysqldump fails (but gzip succeeds) in `mysqldump |gzip`
set -o pipefail
# Turn on traces, useful while debugging but commented out by default
# set -o xtrace

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  __i_am_main_script="0" # false

  if [[ "${__usage+x}" ]]; then
    if [[ "${BASH_SOURCE[1]}" = "${0}" ]]; then
      __i_am_main_script="1" # true
    fi

    __b3bp_external_usage="true"
    __b3bp_tmp_source_idx=1
  fi
else
  __i_am_main_script="1" # true
  [[ "${__usage+x}" ]] && unset -v __usage
  [[ "${__helptext+x}" ]] && unset -v __helptext
fi

# Set magic variables for current file, directory, os, etc.
__dir="$(cd "$(dirname "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")" && pwd)"
__file="${__dir}/$(basename "${BASH_SOURCE[${__b3bp_tmp_source_idx:-0}]}")"
__base="$(basename "${__file}" .sh)"
# shellcheck disable=SC2034,SC2015
__invocation="$(printf %q "${__file}")$( (($#)) && printf ' %q' "$@" || true)"

__functionName="${FUNCNAME:-.}"
# Define the environment variables (and their defaults) that this script depends on
LOG_LEVEL="${LOG_LEVEL:-6}" # 7 = debug -> 0 = emergency
NO_COLOR="${NO_COLOR:-}"    # true = disable color. otherwise autodetected


### Functions
##############################################################################

function __b3bp_log () {
  local log_level="${1}"
  shift

  # shellcheck disable=SC2034
  local color_debug="\\x1b[35m"
  # shellcheck disable=SC2034
  local color_info="\\x1b[32m"
  # shellcheck disable=SC2034
  local color_notice="\\x1b[34m"
  # shellcheck disable=SC2034
  local color_warning="\\x1b[33m"
  # shellcheck disable=SC2034
  local color_error="\\x1b[31m"
  # shellcheck disable=SC2034
  local color_critical="\\x1b[1;31m"
  # shellcheck disable=SC2034
  local color_alert="\\x1b[1;37;41m"
  # shellcheck disable=SC2034
  local color_emergency="\\x1b[1;4;5;37;41m"

  local colorvar="color_${log_level}"

  local color="${!colorvar:-${color_error}}"
  local color_reset="\\x1b[0m"

  if [[ "${NO_COLOR:-}" = "true" ]] || { [[ "${TERM:-}" != "xterm"* ]] && [[ "${TERM:-}" != "screen"* ]]; } || [[ ! -t 2 ]]; then
    if [[ "${NO_COLOR:-}" != "false" ]]; then
      # Don't use colors on pipes or non-recognized terminals
      color=""; color_reset=""
    fi
  fi

  # all remaining arguments are to be printed
  local log_line=""

  while IFS=$'\n' read -r log_line; do
    echo -e "$(date -u +"%Y-%m-%d %H:%M:%S UTC") ${color}$(printf "[%9s]" "${log_level}")${color_reset} ${log_line}" 1>&2
  done <<< "${@:-}"
}

function emergency () {                                __b3bp_log emergency "${@}"; exit 1; }
function alert ()     { [[ "${LOG_LEVEL:-0}" -ge 1 ]] && __b3bp_log alert "${@}"; true; }
function critical ()  { [[ "${LOG_LEVEL:-0}" -ge 2 ]] && __b3bp_log critical "${@}"; true; }
function error ()     { [[ "${LOG_LEVEL:-0}" -ge 3 ]] && __b3bp_log error "${@}"; true; }
function warning ()   { [[ "${LOG_LEVEL:-0}" -ge 4 ]] && __b3bp_log warning "${@}"; true; }
function notice ()    { [[ "${LOG_LEVEL:-0}" -ge 5 ]] && __b3bp_log notice "${@}"; true; }
function info ()      { [[ "${LOG_LEVEL:-0}" -ge 6 ]] && __b3bp_log info "${@}"; true; }
function debug ()     { [[ "${LOG_LEVEL:-0}" -ge 7 ]] && __b3bp_log debug "${@}"; true; }

function help () {
  echo "" 1>&2
  echo " ${*}" 1>&2
  echo "" 1>&2
  echo "  ${__usage:-No usage available}" 1>&2
  echo "" 1>&2

  if [[ "${__helptext:-}" ]]; then
    echo " ${__helptext}" 1>&2
    echo "" 1>&2
  fi

  exit 1
}


### Parse commandline options
##############################################################################

# Commandline options. This defines the usage page, and is used to parse cli
# opts & defaults from. The parsing is unforgiving so be precise in your syntax
# - A short option must be preset for every long option; but every short option
#   need not have a long option
# - `--` is respected as the separator between options and arguments
# - We do not bash-expand defaults, so setting '~/app' as a default will not resolve to ${HOME}.
#   you can use bash variables to work around this (so use ${HOME} instead)

# shellcheck disable=SC2015
[[ "${__usage+x}" ]] || read -r -d '' __usage <<-'EOF' || true # exits non-zero when EOF encountered
  -e --environment [arg] Environment from which to create a local site from. If non is provided the current branch in src will be used.
  -m --mode [arg] Mode in which to initialize the local environment in: production, developer. Required. Default="developer"
  -p --pass-cached-db If provided the script will download a fresh db dump from the environment.
  -t --strip [arg] magerun code for stripping tables. Default="@development"
  -w --domain [arg] Domain name to initialize the local website with.
  -s --sync-mode [arg] Docker sync strategy to use: native, docker-sync, mutagen. Required. Default="native"
  -c --skip-get-config Skip Generating and getting the config file of a remote environment.
  -g --xdebug-enable [arg] Includes an xdebug container with the initial composer build. Default="false"
  -r --dump-file [arg] Path to sql.gz dump file that will be used instead of getting the db from an environment. Default=""
  -v               Enable verbose mode, print script as it is executed
  -d --debug       Enables debug mode
  -h --help        This page
  -n --no-color    Disable color output
  -1 --one         Do just one thing
EOF

# shellcheck disable=SC2015
[[ "${__helptext+x}" ]] || read -r -d '' __helptext <<-'EOF' || true # exits non-zero when EOF encountered
Script to initialize a fresh local environment exactly like a remote cloud environment.
if the -f option is used with a file path, the script will use a db dump instead of getting one from the enviornment.
EOF

# Translate usage string -> getopts arguments, and set $arg_<flag> defaults
while read -r __b3bp_tmp_line; do
  if [[ "${__b3bp_tmp_line}" =~ ^- ]]; then
    # fetch single character version of option string
    __b3bp_tmp_opt="${__b3bp_tmp_line%% *}"
    __b3bp_tmp_opt="${__b3bp_tmp_opt:1}"

    # fetch long version if present
    __b3bp_tmp_long_opt=""

    if [[ "${__b3bp_tmp_line}" = *"--"* ]]; then
      __b3bp_tmp_long_opt="${__b3bp_tmp_line#*--}"
      __b3bp_tmp_long_opt="${__b3bp_tmp_long_opt%% *}"
    fi

    # map opt long name to+from opt short name
    printf -v "__b3bp_tmp_opt_long2short_${__b3bp_tmp_long_opt//-/_}" '%s' "${__b3bp_tmp_opt}"
    printf -v "__b3bp_tmp_opt_short2long_${__b3bp_tmp_opt}" '%s' "${__b3bp_tmp_long_opt//-/_}"

    # check if option takes an argument
    if [[ "${__b3bp_tmp_line}" =~ \[.*\] ]]; then
      __b3bp_tmp_opt="${__b3bp_tmp_opt}:" # add : if opt has arg
      __b3bp_tmp_init=""  # it has an arg. init with ""
      printf -v "__b3bp_tmp_has_arg_${__b3bp_tmp_opt:0:1}" '%s' "1"
    elif [[ "${__b3bp_tmp_line}" =~ \{.*\} ]]; then
      __b3bp_tmp_opt="${__b3bp_tmp_opt}:" # add : if opt has arg
      __b3bp_tmp_init=""  # it has an arg. init with ""
      # remember that this option requires an argument
      printf -v "__b3bp_tmp_has_arg_${__b3bp_tmp_opt:0:1}" '%s' "2"
    else
      __b3bp_tmp_init="0" # it's a flag. init with 0
      printf -v "__b3bp_tmp_has_arg_${__b3bp_tmp_opt:0:1}" '%s' "0"
    fi
    __b3bp_tmp_opts="${__b3bp_tmp_opts:-}${__b3bp_tmp_opt}"

    if [[ "${__b3bp_tmp_line}" =~ ^Can\ be\ repeated\. ]] || [[ "${__b3bp_tmp_line}" =~ \.\ *Can\ be\ repeated\. ]]; then
      # remember that this option can be repeated
      printf -v "__b3bp_tmp_is_array_${__b3bp_tmp_opt:0:1}" '%s' "1"
    else
      printf -v "__b3bp_tmp_is_array_${__b3bp_tmp_opt:0:1}" '%s' "0"
    fi
  fi

  [[ "${__b3bp_tmp_opt:-}" ]] || continue

  if [[ "${__b3bp_tmp_line}" =~ ^Default= ]] || [[ "${__b3bp_tmp_line}" =~ \.\ *Default= ]]; then
    # ignore default value if option does not have an argument
    __b3bp_tmp_varname="__b3bp_tmp_has_arg_${__b3bp_tmp_opt:0:1}"

    if [[ "${!__b3bp_tmp_varname}" != "0" ]]; then
      # take default
      __b3bp_tmp_init="${__b3bp_tmp_line##*Default=}"
      # strip double quotes from default argument
      __b3bp_tmp_re='^"(.*)"$'
      if [[ "${__b3bp_tmp_init}" =~ ${__b3bp_tmp_re} ]]; then
        __b3bp_tmp_init="${BASH_REMATCH[1]}"
      else
        # strip single quotes from default argument
        __b3bp_tmp_re="^'(.*)'$"
        if [[ "${__b3bp_tmp_init}" =~ ${__b3bp_tmp_re} ]]; then
          __b3bp_tmp_init="${BASH_REMATCH[1]}"
        fi
      fi
    fi
  fi

  if [[ "${__b3bp_tmp_line}" =~ ^Required\. ]] || [[ "${__b3bp_tmp_line}" =~ \.\ *Required\. ]]; then
    # remember that this option requires an argument
    printf -v "__b3bp_tmp_has_arg_${__b3bp_tmp_opt:0:1}" '%s' "2"
  fi

  # Init var with value unless it is an array / a repeatable
  __b3bp_tmp_varname="__b3bp_tmp_is_array_${__b3bp_tmp_opt:0:1}"
  [[ "${!__b3bp_tmp_varname}" = "0" ]] && printf -v "arg_${__b3bp_tmp_opt:0:1}" '%s' "${__b3bp_tmp_init}"
done <<< "${__usage:-}"

# run getopts only if options were specified in __usage
if [[ "${__b3bp_tmp_opts:-}" ]]; then
  # Allow long options like --this
  __b3bp_tmp_opts="${__b3bp_tmp_opts}-:"

  # Reset in case getopts has been used previously in the shell.
  OPTIND=1

  # start parsing command line
  set +o nounset # unexpected arguments will cause unbound variables
                 # to be dereferenced
  # Overwrite $arg_<flag> defaults with the actual CLI options
  while getopts "${__b3bp_tmp_opts}" __b3bp_tmp_opt; do
    [[ "${__b3bp_tmp_opt}" = "?" ]] && help "Invalid use of script: ${*} "

    if [[ "${__b3bp_tmp_opt}" = "-" ]]; then
      # OPTARG is long-option-name or long-option=value
      if [[ "${OPTARG}" =~ .*=.* ]]; then
        # --key=value format
        __b3bp_tmp_long_opt=${OPTARG/=*/}
        # Set opt to the short option corresponding to the long option
        __b3bp_tmp_varname="__b3bp_tmp_opt_long2short_${__b3bp_tmp_long_opt//-/_}"
        printf -v "__b3bp_tmp_opt" '%s' "${!__b3bp_tmp_varname}"
        OPTARG=${OPTARG#*=}
      else
        # --key value format
        # Map long name to short version of option
        __b3bp_tmp_varname="__b3bp_tmp_opt_long2short_${OPTARG//-/_}"
        printf -v "__b3bp_tmp_opt" '%s' "${!__b3bp_tmp_varname}"
        # Only assign OPTARG if option takes an argument
        __b3bp_tmp_varname="__b3bp_tmp_has_arg_${__b3bp_tmp_opt}"
        __b3bp_tmp_varvalue="${!__b3bp_tmp_varname}"
        [[ "${__b3bp_tmp_varvalue}" != "0" ]] && __b3bp_tmp_varvalue="1"
        printf -v "OPTARG" '%s' "${@:OPTIND:${__b3bp_tmp_varvalue}}"
        # shift over the argument if argument is expected
        ((OPTIND+=__b3bp_tmp_varvalue))
      fi
      # we have set opt/OPTARG to the short value and the argument as OPTARG if it exists
    fi

    __b3bp_tmp_value="${OPTARG}"

    __b3bp_tmp_varname="__b3bp_tmp_is_array_${__b3bp_tmp_opt:0:1}"
    if [[ "${!__b3bp_tmp_varname}" != "0" ]]; then
      # repeatables
      # shellcheck disable=SC2016
      if [[ -z "${OPTARG}" ]]; then
        # repeatable flags, they increcemnt
        __b3bp_tmp_varname="arg_${__b3bp_tmp_opt:0:1}"
        debug "cli arg ${__b3bp_tmp_varname} = (${__b3bp_tmp_default}) -> ${!__b3bp_tmp_varname}"
        __b3bp_tmp_value=$((${!__b3bp_tmp_varname} + 1))
        printf -v "${__b3bp_tmp_varname}" '%s' "${__b3bp_tmp_value}"
      else
        # repeatable args, they get appended to an array
        __b3bp_tmp_varname="arg_${__b3bp_tmp_opt:0:1}[@]"
        debug "cli arg ${__b3bp_tmp_varname} append ${__b3bp_tmp_value}"
        declare -a "${__b3bp_tmp_varname}"='("${!__b3bp_tmp_varname}" "${__b3bp_tmp_value}")'
      fi
    else
      # non-repeatables
      __b3bp_tmp_varname="arg_${__b3bp_tmp_opt:0:1}"
      __b3bp_tmp_default="${!__b3bp_tmp_varname}"

      if [[ -z "${OPTARG}" ]]; then
        __b3bp_tmp_value=$((__b3bp_tmp_default + 1))
      fi

      printf -v "${__b3bp_tmp_varname}" '%s' "${__b3bp_tmp_value}"

      debug "cli arg ${__b3bp_tmp_varname} = (${__b3bp_tmp_default}) -> ${!__b3bp_tmp_varname}"
    fi
  done
  set -o nounset # no more unbound variable references expected

  shift $((OPTIND-1))

  if [[ "${1:-}" = "--" ]] ; then
    shift
  fi
fi


### Automatic validation of required option arguments
##############################################################################

for __b3bp_tmp_varname in ${!__b3bp_tmp_has_arg_*}; do
  # validate only options which required an argument
  [[ "${!__b3bp_tmp_varname}" = "2" ]] || continue

  __b3bp_tmp_opt_short="${__b3bp_tmp_varname##*_}"
  __b3bp_tmp_varname="arg_${__b3bp_tmp_opt_short}"
  [[ "${!__b3bp_tmp_varname}" ]] && continue

  __b3bp_tmp_varname="__b3bp_tmp_opt_short2long_${__b3bp_tmp_opt_short}"
  printf -v "__b3bp_tmp_opt_long" '%s' "${!__b3bp_tmp_varname}"
  [[ "${__b3bp_tmp_opt_long:-}" ]] && __b3bp_tmp_opt_long=" (--${__b3bp_tmp_opt_long//_/-})"

  help "Option -${__b3bp_tmp_opt_short}${__b3bp_tmp_opt_long:-} requires an argument"
done


### Cleanup Environment variables
##############################################################################

for __tmp_varname in ${!__b3bp_tmp_*}; do
  unset -v "${__tmp_varname}"
done

unset -v __tmp_varname


### Externally supplied __usage. Nothing else to do here
##############################################################################

if [[ "${__b3bp_external_usage:-}" = "true" ]]; then
  unset -v __b3bp_external_usage
  return
fi


### Signal trapping and backtracing
##############################################################################

function __b3bp_cleanup_before_exit () {
  info "Cleaning up. Done"
}
trap __b3bp_cleanup_before_exit EXIT

# requires `set -o errtrace`
__b3bp_err_report() {
    local error_code=${?}
    error "Error in ${__file} in function ${1} on line ${2}"
    exit ${error_code}
}
# Uncomment the following line for always providing an error backtrace
# trap '__b3bp_err_report "${FUNCNAME:-.}" ${LINENO}' ERR


### Command-line argument switches (like -d for debugmode, -h for showing helppage)
##############################################################################

# debug mode
if [[ "${arg_d:?}" = "1" ]]; then
  LOG_LEVEL="7"
fi

# verbose mode
if [[ "${arg_v:?}" = "1" ]]; then
  set -o verbose
fi

# no color mode
if [[ "${arg_n:?}" = "1" ]]; then
  NO_COLOR="true"
fi

# help mode
if [[ "${arg_h:?}" = "1" ]]; then
  # Help exists with code 1
  help "Help using ${0}"
fi

debug "Bypass cache?: ${arg_p}"

##Setup Source Directory to Magento project files
#get temp src path. TODO: Should be cleaned up to use src config value directly
local temp_src_rev=$(bash ./bin/lib/ini_val.sh ./project.ini default.SOURCE_DIRECTORY_NAME)
local RELATIVE_SRC_PATH="../../${temp_src_rev}"
local SRC_DIR=$(cd ${__dir}/${RELATIVE_SRC_PATH} && pwd || emergency "Source path does not exist: ${__dir}/${RELATIVE_SRC_PATH}")
debug "Magento Source Directory: ${SRC_DIR}"

### Validation. Error out if the things required for your script are not present
##############################################################################
notice "Running validation checks!"
  [[ "$(ls -A ${SRC_DIR}/vendor/)" ]] && info "Validation Check: Magento 2 project file composer dependencies installed." || emergency "Failed to initialize project. Make sure that you have installed composer dependencies."

  if ! command -v magento-cloud &> /dev/null
  then
      emergency "magento-cloud could not be found. The Magento Cloud Client tool is required in order to initialize the website."
  else
    info "Validation Check: magento-cloud client tool installed."
  fi

  [[ "${LOG_LEVEL:-}" ]] || emergency "Cannot continue without LOG_LEVEL. "
notice "Done running validation checks!"

### Runtime
##############################################################################
source ./bin/lib/ini_val.sh

#Config values
local CONFIG_SOURCE_DIR_NAME=$(ini_val ./project.ini default.SOURCE_DIRECTORY_NAME)
debug "Config Project Source Directory: ${CONFIG_SOURCE_DIR_NAME}"

local siteDomain=$(ini_val ./project.ini default.DEFAULT_LOCAL_HOST)

if [[ -z ${arg_w} ]]; then
    siteDomain=${arg_w}
    notice "Using script value for domain configuration: ${siteDomain}"
else

  if [[ -z ${siteDomain} ]]; then
    notice "Using project config for domain configuration: ${siteDomain}"
  else
   emergency "A local domain is required either to be provided via the command or configured within the project.ini file."
  fi
fi

debug "Config Site Domain: ${siteDomain}"

notice "Ensuring local project files have correct permissions before initializing the project. "
bin/docker/fix-file-permissions || emergency "Failed to fix file permissions. Exiting script until issue is fixed to ensure correct initialization."
notice "Done ensuring local project files have correct permissions before initializing the project. "
  if [[ -z "${arg_e}" ]]; then
    local environment=$( cd ${CONFIG_SOURCE_DIR_NAME} && git rev-parse --abbrev-ref HEAD)
    notice "Using local branch as environment."
  else
    local environment=${arg_e}
    notice "Using argument environment flag."
  fi
  if [[ "${arg_g}" = "true" ]]; then
    local xdebugFlag="--with-xdebug true"
    notice "Building compose with xdebug flag"
  else
    local xdebugFlag="--with-xdebug false"
  fi

debug "Environment: ${environment}"
debug "Mode: ${arg_m}"

notice "Creating a local environment from ${environment}"

  local dumpPath="${SRC_DIR}/.docker/mysql/docker-entrypoint-initdb.d"

  bin/docker/removeall || warning "An error occured while removing all data containers"

  info "Starting DB setup process"
  #Check that there is actually a DB dump file available.
  local backupFilePath=${arg_r}
  if [[ "${arg_p}" = "1" ]] || [[ "${backupFilePath}" != "" ]]; then
    if [[ "${backupFilePath}" = "" ]]; then
      notice "Getting a ${arg_t} fresh copy of the ${environment} DB"
        info "Clearing out old dump files in ${dumpPath}"
        rm -rf  ${dumpPath}/*.sql && info "Cleared out existing backup files in ${dumpPath}"
        bin/cloud/get-db-for-docker --source-environment ${environment}  --strip ${arg_t} || error "Error Exporting ${arg_t} on ${environment}"
      notice "Done getting a fresh copy of the ${environment} DB"
    else
      #TODO: Not working. There is some issue with the DB credentials.
      if [[ -f "${backupFilePath}" ]]; then
        notice "Setting up local db backup file '${backupFilePath}' for local environment import."
          rm -rf  ${dumpPath}/*.sql && info "Cleared out existing backup files in ${dumpPath}"

          local backupFileName=$(basename -- ${backupFilePath})
          local backupDockerImportFilename=${dumpPath}/${backupFileName%%.*}.sql
          debug "Backup FileName: ${backupFileName}"
          debug "Docker Backup Import Filename: ${backupDockerImportFilename}"
          zcat ${backupFilePath} | sed -e 's/DEFINER[ ]*=[ ]*[^*]*\*/\*/' |  pv -W  >  ${backupDockerImportFilename} && info "Docker import db file created at ${backupDockerImportFilename}"
          notice "Done setting up local db backup file '${backupFilePath}' for local environment import."
          debug "Docker backup db import file: $(ls -lah ${backupFilePath})"
      else
        emergency "Could not initialize local ${environment} environment from backup db file. File ${backupFilePath} does not exist."
      fi
    fi
  else
    local allDumpFiles=( $(find ${dumpPath}/ -maxdepth 1 -name "*.sql") )
    local count=${#allDumpFiles[@]}

    debug "Dump file path: ${dumpPath}"
    debug "Dump file count: ${count}"

    if [[ ${count} = 0 ]]; then
      emergency "No DB dump files in ${dumpPath}. A local environment cant be initialized using cached method. Use -p option to bypass the cache requirement."
    fi
    if [[ ${count} > 1 ]]; then
      error "There should only be one dump file in ${dumpPath}" && ls -lah ${dumpPath} && emergency "Too many dump files"
    fi
    info "Using cached db dump in ${dumpPath}"
  fi
  notice "Done starting DB setup process"

  notice "Cleaning local environment of old files and data"
    bin/docker/removeall || warning "An error occured while removing all data containers"
    rm -f ${CONFIG_SOURCE_DIR_NAME}/.docker/config.php && info "Removed docker config.php"
    rm -f ${CONFIG_SOURCE_DIR_NAME}/docker-compose.override.yml && info "Removed docker compose override"
    rm -f ${CONFIG_SOURCE_DIR_NAME}/docker-compose.yml && info "Removed docker compose file"
    rm -f ${CONFIG_SOURCE_DIR_NAME}/app/etc/env.php && info "Removed env.php"
  notice "Done cleaning local environment of old files and data"

  notice "Setting up local config files"
    if [[ "${arg_c}" = "0" ]]; then
      bin/cloud/get-latest-config --environment ${environment}
      #TODO: Change flag to --environment
      bin/cloud/get-env-file -e ${environment}
    else
      info "Skipping getting the latest config from ${environment}" && debug "Skip Config Flag:${arg_c}"
    fi

    bin/docker/setup-docker-compose-override -d ${arg_d} --mode ${arg_m} --sync-mode ${arg_s}

    bin/docker/build-compose ${xdebugFlag}  --environment ${environment} --mode ${arg_m} --sync-mode ${arg_s}  --host ${siteDomain}

    bin/docker/setup-domain  --mode ${arg_m} --new-domain ${siteDomain} --sync-mode ${arg_s}

    bin/docker/build-compose ${xdebugFlag} --environment ${environment} --mode ${arg_m} --sync-mode ${arg_s}  --host ${siteDomain}

    if [[ "${arg_g}" = "true" ]]; then
      bin/docker/xdebug  --enable --mode ${arg_m} --sync-mode ${arg_s} --domain ${siteDomain}
    else
      bin/docker/xdebug  --disable --mode ${arg_m} --sync-mode ${arg_s} --domain ${siteDomain}
    fi

  notice "Done setting up local config files"


  if [[ "${arg_m}" = "developer" ]]; then
    notice "Setting up docker container files"
      bin/docker/sync-start --sync-mode ${arg_s}
    notice "Done setting up docker container files"
  fi

  notice "Starting local environment init process"
    bin/docker/deploy --mode ${arg_m}

    bin/docker/start

    info "Running a full reindex"
      bin/docker/magento indexer:reindex
      bin/docker/magento indexer:reindex catalogsearch_fulltext
    info "Done reindexing"

    bin/docker/magento cache:enable && info "Manually enabled all caches"

    bin/docker/magento cache:flush && info "Flushing the cache"
  notice "Done local environment init process"
  bin/docker/setup-admin || warning "Failed to setup a default admin account"
  debug "Environment: ${environment}"
  debug "Mode: ${arg_m}"
  notice "Done Creating a local environment from ${environment}"
}

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
  export -f initi-local-environment
else
  initi-local-environment "${@}"
  exit ${?}
fi